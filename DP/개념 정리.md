# 다이나믹 프로그래밍

+ 다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법이다.
+ 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
+ 구현 방법은 두 가지 방식인 top-down, bottom-up으로 구성된다.

### DP 사용 조건
#### 1. 최적 부분 구조
+ 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제 해결 가능할 때
####  2. 중복되는 부분 문제
+ 어떤 문제를 해결하기 위해서 동일한 작은 문제가 반복적으로 호출될 때

### 분할 정복과의 차이점
+ DP 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복된다.
+ 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.

> 피보나치 수열

+ 점화식: 인접한 항들 사이의 관계식
+ 프로그래밍에서는 수열을 배열이나 리스트를 이용해 표현한다.

```python
def fibo(x):
    if x == 1 or x == 2:    
        return 1
    return fibo(x-1) + fibo(x-2)
    
print(fibo(4))
```
+ 사용 조건: 중복되는 부분 문제  
   + f(6)을 구하기 위해서 f(2)를 여러번 호출해야 함

## DP 구현 방법
### Top-Down 방식인 메모이제이션(Memoization)
+ 큰 문제를 해결하기 위해서 작은 문제를 재귀적으로 호출하여, 작은 문제가 해결되었을 때 큰 문제에 대한 답까지 얻을 수 있도록 한다. => 재귀 함수 활용

+ 한 번 계산한 결과를 메모리 공간에 메모하는 기법
   + 같은 문제를 호출하면 메모했던 결과를 그대로 가져온다.
   + 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 한다.

+ 시간 복잡도: O(N)

```python
# 계산된 결과를 메모이제이션하기 위한 리스트 초기화
cache = [0]*100

def fibo(x):
    
    # 종료 조건
    if x == 1 or x == 2:    
        return 1
    
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if cache[x] != 0:
        return cache[x]
    
    # 계산한 적 없는 문제라면 피보나치 결과 반환하여 cache에 저장
    cache[x] = fibo(x-1) + fibo(x-2)
    
    return cache[x]
    
print(fibo(99))
```

### Bottom-Up 방식
+ 작은 문제를 하나씩 해결해 나가면서, 먼저 계산했던 문제들의 값을 활용해서 다음의 문제까지 차례로 해결한다. => 반복문 활용

```python
d = [0]*100

d[0] = 1
d[1] = 1
n = 99

# i=3인 작은 문제부터 해결해 놓은 다음, 이 것을 조합하여 큰 문제를 해결하는 방식
for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]
    
print(d[n])
```

### DP 문제에 접근하는 방법
+ 주어진 문제가 DP인지 파악하는 법
   + 그리디, 구현, 완전 탐색으로 해결되는지 먼저 검토
   + 최적 부분 구조, 중복되는 부분 문제인지 확인

### 문제 풀이
> **개미전사**      
> 일직선의 식량창고 N개에서 최소한 한 칸 이상 떨어진 식량 창고를 약탈하여 얻을 수 있는 식량의 최댓값 구하기     

+ 정당성 검토: 인접한 노드에 영향을 받음, 작은 문제로 나눌 수 있음   
+ 문제 해결의 흐름  
=> 최대한 작은 값을 비교하는 방법으로 범위 줄여나가기
   + 마지막 식량창고를 약탈하면서 최적의 해 or 마지막 식량창고 약탈하지 않으면서 최적의 해 중 더 큰 값 구하기      
   + 인덱스를 줄여나가면서 작은 문제로 바뀜

+ 점화식: a(i) = max(a(i-1), a(i-2)+k(i))
   + a(i) = i번째 식량창고까지의 최적의 해
   + k(i) = i번째 식량창고에 있는 식량의 양

```python
n = int(input())
array = list(map(int, input().split()))

d = [0] * 100

# Bottom-Up 방식
d[0] = array[0]
d[1] = max(array[0], array[1])
for i in range(2, n):
    d[i] = max(d[i-1], d[i-2]+array[i])

print(d[n-1])
```

> **1로 만들기**      
> 연산 4개를 적절히 사용해서 1로 만들 때, 연산을 사용하는 횟수의 최솟값을 출력하라.
> 1. X가 5로 나누어 떨어지면, 5로 나누기    
> 2. X가 3으로 나누어 떨어지면, 3으로 나누기     
> 3. X가 2로 나누어 떨어지면, 2로 나누기      
> 4. X에서 1빼기     

+ 정당성 검토: 최적 부분 구조와 중복되는 부분 문제 만족 (트리로 도식화할 수 있음)
   + 각각의 값을 구하기 위해서 더 작은 문제의 값이 필요함
   + X가 6일 때의 최적의 해 = X가 5일 때의 최적의 해, X가 3일 때의 최적의 해, X가 2일 때의 최적의 해 중 가장 작은 값을 고르면 됨

+ 점화식: a(i) = min(a(i-1), a(i/2), a(i/3), a(i/5)) + 1

```python
x = int(input())
d = [0] * 30001

for i in range(2, x+1): 

    d[i] = d[i-1] + 1
    
    if i % 2 == 0:
        d[i] = min(d[i], d[i//2]+1)
    if i % 3 == 0:
        d[i] = min(d[i], d[i//3]+1)
    if i % 5 == 0:
        d[i] = min(d[i], d[i//5]+1) 

print(d[x])
```
> **효율적인 화폐 구성**    
> N가지 종류의 화폐, M원을 만들기 위한 최소한의 화폐 개수를 출력하라. (1 <= N <= 100, 1 <= M <= 10000)       
> 불가능할 때는 -1 출력     

+ 정당성 검토: 최적 부분 구조와 중복되는 부분 문제 만족 (트리로 도식화할 수 있음)
   + 각각의 값을 구하기 위해서 더 작은 문제의 값이 필요함
   
+ 점화식: 화폐 단위인 k를 확인하며
   + (a-k)값이 있는 경우: a(i) = min(a(i), a(i-k)+ 1)
   + (a-k)값이 없는 경우: a(i) = INF (임의의 무한대 값 -> 10001)

+ 시간복잡도: O(N x M) = 백만

```python
n, m = map(int, input().split())

# N개의 화폐 단위 정보 입력
array = []
for i in range(n):
    array.append(int(input())
    
# 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m+1)

# Bottom-Up
d[0] = 0
for i in range(n):    # i = 각각의 화폐단위, j = 각각의 금액 / 각각의 화폐단위를 모두 확인하며 그 때에 대해서 모든 금액을 확인하며 그에 대한 최적의 해를 갱신
    for j in range(array[i], m+1):    # 해당 화폐단위 ~ 끝까지
        if d[j-array[i]] != 10001:   
            d[j] = min(d[j], d[j - array[i]] + 1)
            
if d[m] == 10001:
    print(-1)

else:
    print(d[m])
```

> **금광**     
> n x m 크기의 금광, 1 x 1 크기의 칸으로 나누어져있고 그 안에 특정 크기의 금이 있음      
> 1열부터 시작해서 오른쪽 위, 오른쪽, 오른쪽 아래 3가지 중 하나로 이동해야 한다. 얻을 수 있는 금의 최대 크기를 구하라.     

```python
for tc in range(int(input())):
    
    # 금광 정보 입력
    n, m = map(int, input().split())
    array = list(map(int, input().split()))
    
    # 2차원 dp 테이블 초기화
    dp = []
    index = 0
    for i in range(n):
        dp.append(array[index:index+m])
        index += m
    
    # dp 진행
    for j in range(1, m):    # 각 열마다 전체 행을 확인
        for i in range(n):
            # 왼쪽 위에서 오는 경우
            if i == 0: left_up = 0    # 인덱스에서 벗어나면 0으로 초기화
            else: left_up = dp[i-1][j-1]
            # 왼쪽 아래에서 오는 경우
            if i == n-1: left_down = 0   # 인덱스에서 벗어나면 0으로 초기화  
            else: left_down = dp[i+1][j-1]
            # 왼쪽에서 오는 경우
            left = dp[i][j-1]   
            dp[i][j] = dp[i][j] + max(left_up, left_down, left)
    result = 0
    
    # 가장 오른쪽 열 중 가장 큰 값을 찾아 출력
    for i in range(n):
        result = max(result, dp[i][m-1])
    print(result)
```

> **병사 배치하기**    
> N명의 병사를 전투력이 높은 병사가 앞쪽에 오도록 내림차순으로 배치, 이 때 특정한 병사를 열외시키는 방법을 이용 (1 <= N <= 2000)       
> 남아있는 병사의 수를 최대로 하여 열외해야 하는 병사 수를 출력하라. 

+ 시간 복잡도: 시간제한이 1초이므로 O(N^2)이하의 시간복잡도를 가진 알고리즘을 선택해야 함.

+ 문제 해결 아이디어
   + 가장 긴 증가하는 부분 수열(LIS)
   ``` 
   모든 0 <= j < i 에 대하여, D[i] = max(D[i], D[j]+1) if array[j] < array[i]
   ```
   + 가장 먼저 입력받은 병사 정보의 순서를 뒤집어 LIS 알고리즘을 수행한다.


```python
n = int(input())
array = list(map(int, input().split()))
array.reverse()

dp = [1] * n

for i in range(1, n):
    for j in range(0, i):
        if array[j] < array[i]:
            dp[i] = max(dp[i], dp[j] + 1)

print(n - max(dp))
```
